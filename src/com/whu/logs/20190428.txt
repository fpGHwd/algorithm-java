继承二
	继承体系中的功能
		1. 父类的描述 父类中具有共性功能 共性功能=体系功能 了解体系
		2. 具体调用创建最子类：一是父类可能不能实例化，二是子类具有更多的功能


聚集关系
	聚集 has a
	聚合
	组合

子父类变量的特点
	super 父类对象的引用 所在区域是非静态区-堆区域
	this 和 super 分别是子引用和父引用
	猫是一个动物
	
子父类中函数的特点-覆盖
	overide 保持父类功能定义以及重写具体功能
	修改源码是灾难 开闭原则
	新出的手机和老的手机在时间上具有关系，运用继承机制
		super.show(); 父类已经做了的动作，包含于重写 覆盖功能 重用代码
	子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖
	静态只能覆盖静态
	默认权限？
	重载和重写
		重载：函数的参数列表
		重写：函数必须一模一样。如果函数【返回类型】不一样但是函数名一样。编译错误。

子父类中函数的特点-子类实例化过程
	子类构造函数默认第一条语句super();没有父哪有子
	为什么子类一定要访问父类函数。
		当父类函数只有一个非默认的构造函数，那么子类要指定这个构造函数。
	题外话：java的网络性能不用就是浪费。万物皆序列和时空。网络功能就这样。java。网络的数学分析
	重用代码super(name);
	this语句和super语句构造函数块首句智能其一
	this(6);this();没爹的孩子。子类中至少有一个构造函数去访问父类
	子类的所有的狗仔函数，默认都会访问父类中空参数的构造函数
		当父类没有空参数构造函数时，子类中需要手动通过super语句去访问父类构造函数
		子类可以通过this来访问本类的构造函数
		子类中至少有一个构造函数去访问父类
		
final关键字
	终版类
	修饰符 最终的 不容许继续继承的类
		修饰类、变量、函数
	继承的覆写 功能禁止覆写

抽象类
	abstract “看不懂”
	和 interface的关系

抽象类2
	强迫子类做一些事情 abstract extends
	抽象类中可以定义正常的方法
	题外话：所以即使是abstract也是在整个体系中调整关系 并没有什么特别的不同。
		比如强迫子类做一些事情
		比如内部方法有abstract方法，那么该类就必然是抽象类
		课程就是重点的地方和内容。关键和节约时间。
	并不让该类建立对象，不然就不是abstract类。
	特殊用法：抽象类中不定义抽象方法，仅仅是不让该类实例化对象

抽象类 练习
	题外话：实例抽象化成为类，类继续抽象出实体出父类。
	描述不到具体的地方就是用抽象方法。。。那么也是抽象类
		只要是公司员工就必须要工作
		
模版方法模式
	需求：获取一段程序的运行时间
	计时的方法 代码是不一样的
		有代码重复很高的形式
		函数可以封装代码
	模版方法？
		覆写一个runcode，提供一个代码块给子类覆写
			抽象方法，抽象类
			有些类不能覆写，就不能覆写，使用final
			
接口
	格式：
		常量(public static final)int NUM,全局常量NUM
		和方法(public abstract) void show();
		Implements
	编译：一个文件里里面有好几个类，还是会生成好几个类的文件
	
接口二
	接口可以被类多实现 
		多实现中两个接口具有相同的方法
			没有方法实体
	继承一个类还实现其他的类
	接口间的关系有继承interface B extends A
	接口间有多继承
		没有方法体不冲突
	java有多继承，只有在接口与接口之间存在多继承
	
接口的特点
	接口：主板和CPU之间的协议——槽
	插和焊->关系比较弱了->耦合性降低
	好处：暴露规则，功能拓展，降低耦合性
	制定规则就是创建核心，降低耦合性
	
接口举例体现 
	小点：Zhangsan只是一个对象的类，所以只是一个对象而不是类
	abstract抽烟方法
		张三必须得抽烟
		不是共性方法，设计要用接口实现
	体系以外的功能接口
		体系（继承）以外的功能（额外方法）接口 interface 特性
		功能拓展
	题外话
		重要的话的理解。。。然后就是本身这个org-mode文件，在需要核心的地方有核心的互动规则 。所以不能把细节和所有的东西归为一起。有时候时间的计算规则都不一样。比如核心可能是以天来计算的，但是非核心的东西可能以小时和分钟来计算的。

多态-概念
	某种事物的多种形态
		人分为男人和女人
	对象和非对象层面
		对象：类方面
		非类方面：重载和覆盖
	
多态-拓展性
	失态：不实现abstract方法
	一个对象具有多种形态
		Animal c = new Cat(); c.eat();
	abstract强制拓展和实现功能
	体现 父类的引用指向指向了自己的子类对象
	前提 必须是类和类之间的关系 要么继承要么实现
	好处 代码拓展性
	弊端 只能使用父类的引用访问父类中的成员
	最终 代码复用
		反射

多态-转型
	向上转型 类型提升
	向下转型 强制将父类引用转换成子类类型
	可转换条件 当父类引用指向了自己的子类对象时，引用可以向上转换也可以向下转化
	内存变化过程 多态始终是子类对象在做变化
		毕老师可以转化成毕姥爷，但是毕姥爷不能转换成毕老师	
	类型转换异常的出现 == a的类型不明确，不确定
		if(a instanceof Cat)...
		
多态-示例
	学员
		基础班
		高级班
	把抽出来的方法变成一个类
	所有动物去吃饭

多态的特点 
	非静态成员函数特点：
		多态中：父类指向子类对象
		编译时期
		运行时期 
		编译看左边（类），运行看右边（对象）。 左边就是类，右边就是对象。
	
	成员变量特点：
		
	总之，成员都是一样的。如果成员在静态区，则看左边（即看类）；如果成员在静态去，则看右边（即看对象）。编译时也一样。
	非静态绑定和静态绑定
	
多态的主板示例
	多态 用父类的引用去引用子类对象
	PCI是显卡实现不是主板实现的（主板插在接口上的）。
	接口的出现增加了程序的拓展，同时多态的应用提升了程序的拓展性提升了程序的拓展性
	多态应用 接口型引用指向了（实现）自己的子类对象。

多态的拓展示例
	需求
		对于数据库的操作
			使用JDBC
			使用hibernate
	抽象一层interface。那么客户端代码就要变。如果不变的话，提升代码的复用性就使用多态
		即客户代码使用多态来提升代码的复用性
	UserInfoDao是一个接口，这就是关键的层
	接口开发规则
	题外话：
		解耦 = 添加一层 = 多态。
	反射解决的是什么问题呢？
		类的名字（文件） 加载 进内存（类）
		
Object-equals()
	父类的父类 object
		上帝 上帝没有爹
	没有必要整compare方法 父类已经有了equal方法
		自定义中有相同的功能，没有必要重新定义，覆盖override即可。
		没有向上转型类型是找不到符号的 没有该符号的定义 找不到一个符号 错误信息也是比较空间规律的
		向下转型
	向上转型，如果是
	重写大于自己写
	要快和。。。不要纠结细节。联系才是最重要的

Object类toString()
	直接打印：所有的类+hash值  hash值是依据内存地址的hash值
	hash值的10进制 16进制即 直接打印的值
	用class来描述class文件 内存加载硬盘类文件时 发生在new A();时
	toString() == getClass().getName() + "@" + Integer.toHexString(hashCode());
	动态加载类 与 反射
	JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
		反 + 射 
			但是JAVA有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes
			编译时不知到的类
			
内部类访问规则
	这句话的意思并没有理解清楚，这是以前的一种通病
	内部类 肚子访问心脏
	1. 内部类可以直接访问外部类中的成员，包括私有
	2. 外部类要访问内部类，必须建立内部类对象
	需求：直接访问内部类成员
		Outer.Inner 内部类全名称： Outer.Inner in = new Outer().new Inner();
	外部类成员 内部类成员 内部类局部
		如何在内部类中局部中引用：1.outer.this.x 2.this.x 3.x
		
静态内部类（todo）
	内部类被static修饰，只能访问外部类中static成员
		无法从静态上下文中访问非静态变量
		
内部类定义原则
	当描述事物时，事物的内部还有事物。该事物使用内部类 内部类事物在使用挖补事物的内容。
	
匿名内部类
	absractmethod内部匿名对象
	写起来比较好看，但是阅读性和理解性比较不好
	匿名内部类就是匿名内部子类对象
	匿名内部类方法不能多
	